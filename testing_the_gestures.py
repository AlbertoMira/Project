# -*- coding: utf-8 -*-
"""Testing the gestures.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wOT5l87KtvABZ04MeJAnBoFguPvaK3ky
"""

import tensorflow as tf
from tensorflow import keras
import numpy as np
from sklearn.model_selection import train_test_split
from scipy.fft import fft
import pickle

# This function processes the files regarding the gestures. In the end, it returns
# a 3000x4 numpy array (final_data_1) for every gesture.
# Besides, it also returns a numpy array (final_data_2) of those samples related to a no movement, 
# meaning when no gesture is being made.
def movement_processing():
    processMovement = input("Do you want to process a movement?\n1. Yes\n2. No\n")
    l1=[]
    l2=[]
    while processMovement=="Yes":
        movement = input("Enter the name of the file related to the movement: ")
        numberFiles =int(input("Enter the number of files you have regarding this movement: "))
        for i in range (1,numberFiles+1): #Here, the user enters the number of files. Mind that all file names should follow the same structure.
            if movement =='StrongGrasp':
              f=open(movement+"_"+str(i)+".txt", "r")
              lists=f.readlines()
              lists=lists[3:] #Taking only the information which is useful for us.
              f.close()
              a=np.zeros((1,4))
              c=np.zeros((1,4))
              i=0
              for e in lists: # Basically, for every movement, we store the useful data of the signals.
                              # At the same time, we store information regarding the no movement state.
                              # This is regarding the strong grasp, but the same applies for every movement.
                              # In the numpy array containing the data of the grasp, the information which is not useful
                              # is set to 0. 
                  e=''.join(e)
                  e=e.split(";")
                  if i==0:
                    c[0][0]=int(e[2])
                    c[0][1]=int(e[3])
                    c[0][2]=int(e[4])
                    c[0][3]=int(e[5])
                    a[0][0]=0
                    a[0][1]=0
                    a[0][2]=0
                    a[0][3]=0
                    i=1
                  elif a.shape[0]>0 and a.shape[0]<=1000:
                    a=np.append(a, [[0,0,0,0]], axis=0)
                    c=np.append(c, [[int(e[2]),int(e[3]),int(e[4]),int(e[5])]], axis=0)
    
                  elif a.shape[0]>1000 and a.shape[0]<3000:
                    a=np.append(a, [[int(e[2]),int(e[3]),int(e[4]), int(e[5])]], axis=0)
              while a.shape[0]<3000:
                    a=np.append(a, [[0,0,0, 0]], axis=0)
              l2.append(c)

            elif movement=='WeakGrasp':
                f=open(movement+"_"+str(i)+".txt", "r")
                lists=f.readlines()
                lists=lists[3:]
                f.close()
                a=np.zeros((1,4))
                c=np.zeros((1,4))
                i=0
                for e in lists: 
                    e=''.join(e)
                    e=e.split(";")
                    if i==0:
                      c[0][0]=int(e[2])
                      c[0][1]=int(e[3])
                      c[0][2]=int(e[4])
                      c[0][3]=int(e[5])
                      a[0][0]=0
                      a[0][1]=0
                      a[0][2]=0
                      a[0][3]=0
                      i=1
                    elif a.shape[0]>0 and a.shape[0]<=800:
                      a=np.append(a, [[0,0,0,0]], axis=0)
                      c=np.append(c, [[int(e[2]),int(e[3]),int(e[4]),int(e[5])]], axis=0)
                    elif a.shape[0]>800 and a.shape[0]<=1600:
                      a=np.append(a, [[int(e[2]),int(e[3]),int(e[4]), int(e[5])]], axis=0)
                    elif a.shape[0]>1600 and a.shape[0]<3000:
                      a=np.append(a, [[0,0,0,0]], axis=0)
                while a.shape[0]<3000:
                      a=np.append(a, [[0,0,0, 0]], axis=0)
                l2.append(c)


            elif movement== 'KeyGrasp':
                f=open(movement+"_"+str(i)+".txt", "r")
                lists=f.readlines()
                lists=lists[3:]
                f.close()
                a=np.zeros((1,4))
                i=0
                for e in lists: 
                    e=''.join(e)
                    e=e.split(";")
                    if i==0:
                      a[0][0]=0
                      a[0][1]=0
                      a[0][2]=0
                      a[0][3]=0
                      i=1
                    elif a.shape[0]<3000:
                      a=np.append(a, [[int(e[2]),int(e[3]),int(e[4]), int(e[5])]], axis=0)
                while a.shape[0]<3000:
                      a=np.append(a, [[0,0,0, 0]], axis=0)


            elif movement=='ThumbUp':
                f=open(movement+"_"+str(i)+".txt", "r")
                lists=f.readlines()
                lists=lists[3:]
                f.close()
                a=np.zeros((1,4))
                c=np.zeros((1,4))
                i=0
                for e in lists: 
                    e=''.join(e)
                    e=e.split(";")
                    if i==0:
                      c[0][0]=int(e[2])
                      c[0][1]=int(e[3])
                      c[0][2]=int(e[4])
                      c[0][3]=int(e[5])
                      a[0][0]=0
                      a[0][1]=0
                      a[0][2]=0
                      a[0][3]=0
                      i=1
                    elif a.shape[0]>0 and a.shape[0]<=500:
                      a=np.append(a, [[0,0,0,0]], axis=0)
                      c=np.append(c, [[int(e[2]),int(e[3]),int(e[4]),int(e[5])]], axis=0)
                    elif a.shape[0]>500 and a.shape[0]<=1500:
                      a=np.append(a, [[int(e[2]),int(e[3]),int(e[4]), int(e[5])]], axis=0)
                    elif a.shape[0]>1500 and a.shape[0]<3000:
                      a=np.append(a, [[0,0,0,0]], axis=0)
                while a.shape[0]<3000:
                      a=np.append(a, [[0,0,0, 0]], axis=0)
                l2.append(c)
            else:
                f=open(movement+"_"+str(i)+".txt", "r")
                lists=f.readlines()
                lists=lists[3:]
                f.close()
                a=np.zeros((1,4))
                c=np.zeros((1,4))
                i=0
                for e in lists: 
                    e=''.join(e)
                    e=e.split(";")
                    if i==0:
                      c[0][0]=int(e[2])
                      c[0][1]=int(e[3])
                      c[0][2]=int(e[4])
                      c[0][3]=int(e[5])
                      a[0][0]=0
                      a[0][1]=0
                      a[0][2]=0
                      a[0][3]=0
                      i=1
                    elif a.shape[0]>0 and a.shape[0]<=500:
                      a=np.append(a, [[0,0,0,0]], axis=0)
                      c=np.append(c, [[int(e[2]),int(e[3]),int(e[4]),int(e[5])]], axis=0)
                    elif a.shape[0]>500 and a.shape[0]<=1600:
                      a=np.append(a, [[int(e[2]),int(e[3]),int(e[4]), int(e[5])]], axis=0)
                    elif a.shape[0]>1600 and a.shape[0]<3000:
                      a=np.append(a, [[0,0,0,0]], axis=0)
                while a.shape[0]<3000:
                      a=np.append(a, [[0,0,0, 0]], axis=0)
                l2.append(c)
            
            l1.append(a)

        processMovement = input("Do you want to process a movement?\n1. Yes\n2. No\n")
    
    return (np.array(l1), np.array(l2))

# We get those 2 numpy arrays above mentioned
final_data_1, final_data_2 = movement_processing()

# Gathering the 6 gestures in a single numpy array
l=[]
a=np.zeros((1,4))
for e in final_data_2:
  for i in e:
    if a.shape[0]<3001:
        a=np.append(a, [[int(i[0]),int(i[1]),int(i[2]),int(i[3])]], axis=0)
    else:
      a=a[1:]
      l.append(a)#fft(a))
      a=np.zeros((1,4))
    
b=list(final_data_1)
for e in l:
  b.append(e)
c=np.array(b)
c.shape

# Creating the labels for every gesture
l=[]
i=0
while i<593:
  if i<100:
    l.append(0) #Strong grasp
  elif i>=100 and i<200:
    l.append(1) #Weak grasp
  elif i>=200 and i<300:
    l.append(2) # Key grasp
  elif i>=300 and i<400:
    l.append(3) # Thumbs up
  elif i>=400 and i<500:
    l.append(4) #Rock on
  else:
    l.append(5) #No movement
  i=i+1
b=np.array(l)

X_train, X_test, y_train, y_test = train_test_split(c, b, test_size=0.2) # Split the data

# A part of the training data is reserved as a validation set
x_val = X_train[-100:]
y_val = y_train[-100:]
X_train = X_train[:-100]
y_train = y_train[:-100]

# Model
model = keras.Sequential([
  keras.layers.Flatten(input_shape=(3000,4)),
  keras.layers.Dense(120, activation='relu'),
  keras.layers.Dense(120, activation='relu'),
  keras.layers.Dense(6, activation='softmax') 
])
model.compile(optimizer='Adagrad',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

model.fit(X_train, y_train,epochs=100, validation_data=(x_val, y_val)) # Train the model, 100 epochs

test_loss, test_acc = model.evaluate(X_test,  y_test, verbose=0) # Testing the model
print('Test accuracy:', test_acc)

# Save the data in a pickle file
pickle_file = open('Data.pkl', 'wb')
pickle.dump(c, pickle_file)
pickle_file.close()

# Open the data
pkl_file = open('Data.pkl', 'rb')
processing_data= pickle.load(pkl_file)
pkl_file.close()

# Save the labels in a pickle file
pickle_labels = open('Labels.pkl', 'wb')
pickle.dump(b, pickle_labels)
pickle_labels.close()

# Open the labels
labels_file = open('Labels.pkl', 'rb')
labels= pickle.load(labels_file)
labels_file.close()